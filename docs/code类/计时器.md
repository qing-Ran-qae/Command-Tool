# 计时器

`dv`

此工具可以让命令在`N`tick后执行<br>
也可以很灵活的管理这些延时执行的命令，就像`schedule`命令一样<br>
但此工具是`schedule`命令的加强版

## 方法

### 创建事件

`create`

创建一个事件

```text
[int]exec_t : 延时长度，单位tick
[{}]info : 任意值(如不需要可为空对象)，详细信息见下
[C]run : 此事件执行的指令
[DS][str]replace : 覆盖之前的事件，匹配此参数值中的键是否和已有事件此键值相同，相同则覆盖，none为不覆盖
[int]cycle : 此事件的执行次数，-1为无限循环，0为只执行一次
```

**info**<br>
info 参数用于接入你的系统，在事件中的指令执行时会将此参数的值暂存入`ct:temp exec_event.info`中，在执行完这条指令后自动删除<br>
即你可以在`run`的命令中使用这个键，包括修改这个键<br>

### 删除事件

`remove`

删除一个事件

```text
[DS]target : 要删除的事件，匹配一个事件实例
```

函数内容`$data remove storage ct:code.dv event[$(target)]`

### 提前执行

`execute`

执行一个事件，并在执行后删除这个事件

```text
[DS]target : 要执行的事件，匹配一个事件实例
```

### 检测事件

`has`

检测事件是否存在<br>
返回 0 表示不存在<br>
返回 1 表示存在

```text
[DS]target : 要检测的事件，匹配一个事件实例
```

### 修改事件

`modify`

随时修改一个事件

```text
[DS]target : 要修改的事件，匹配一个事件实例
[DS]from : 要修改的键
[DS]to : 目标值
```

## 事件对象

所有事件存在`ct:code.dv event`键中

格式为:

```text
event: [
    {
        run: "一条指令",                 // 事件执行的指令
        delay : N,                      // 每次执行的间隔
        exec_t: N,                      // 事件对应时钟的时间，匹配则执行事件
        cycle: N,                       // 剩余循环次数
        uuid: [I; xxx,xxx,xxx,xxx],     // 用于区分各个事件
        info: {...},                    // 事件的附带信息
    },
    {
        另一个事件
    }
]
```